# Dataloader's .load()
.load() kicks off a chain of methods that allow us to batch queries for our key's values, and cache the key's value. We're going to talk about the caching aspect first. 

## Caching 
If we dynamically pull all userIds from our blog object, we can't manually tell Node that it doesn't need to query for user59 three times as blog post author and the author of two comments. Ideally, we want a single value representing user59's id (key). If we have such a value, we can cache it, and return a reference to it to all subsequent function calls to load that key, meaning we only have to actually query for it once. When the value for the key is returned from our batched query, the cache value for that key is updated and thus updates all `load(key)` call sites holding a reference to it. That value is, of course, a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) - which is in the pending state until our batched query returns.

## In the source code:
The .load() method of Dataloader starts at line 61 (click the tab!), but it's mostly error/type checking and options
configuration until line 77. On line 77 DataLoader checks
whether the key that we've called `.load()` on has been previously `.load()`'ed and therefore cached. If we set caching to false in Dataloader's optional configuration object, this step is bypassed.

Remember, key we passed to `.load()` could be cached with a value represented by one of two states:

* If .load() was already called on this key in the current execution context, our key is in our cache and returned as a **pending** promise.

* If .load() was called in a previous execution context, the key will be cached as a **resolved** or **rejected** promise. It is rejected if no record exists for the key (null is returned from the database - e.g. the user deleted their acccount).

There's one exception to this caching behaviour, and it's quite logical. If the batchload function itself errors, i.e. we couldn't contact the database (usually due to network error), no rejected promises are cached.  

As for the cache itself, it's simply (by default) an [ES6 Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)

## Where's our animation at?
We just popped `require('./userLoader).default` from line 2 of Main.js off the stack, and returned to Main.js (line 3 and onwards until we hit another function, essentially). Our UserLoader is now configured and exists as an object on the V8 heap.

